---
title: "ncsim"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The theory



## Aim:
   This function leads to a simulation of a gene tree considering the n-coalescent.

## Inputs:
   'n' the number of individuals,
   
   'theta' the population mutation rate,
   
   'T_total' a logical value to give the total branch length of the tree between each coalescent event (i.e. T_total will be the sum of the time given in output).

## Outputs:
   't' a vector with the time spent in each state,
   
   'Vecstates' a vector with the transient state for this simulation,
   
   'Vecmut' the simulated SFS.

```{r}
ncsim = function(n, theta = 10, T_total = FALSE){
  
  # Initialisation
  times = NULL; T_tot = NULL
  
  k = n  # number of distinct lineages
  count = 1  # because k will not goes just from 1 to size 
  Vecstates = matrix(0, nrow=n, ncol=n)
  Vecstates[1, ] = c(n, rep(0, n-1))
  Vecmut = rep(0, n-1)  # the number of mutation (in SFS)

  # This loop will continue until reaching the MRCA
  # (until just one lineage)
  while (k > 1){
    lambda = k*(k-1)/2
    
    # Each coalescent time follow a exp dsitribution
    # with a parameter lambda given by the rate matrix
    times[count] = rexp(n=1, rate=lambda)
    
    if(T_total == TRUE){T_tot[count] = times[count]*k} 
           
    # Need this condition because the last coalescent leads to MRCA
    # and is not represented in the state matrix
    # Vector of probability to go to each other states
    
    Vecnext = Vecstates[count,]
    inext = NULL
    # sample two times instead of one (with size 2)
    # to remove 2 of vecnext if the sample choose 
    # two times the same lineage size
    
    inext[1] = sample(x = 1:n, size = 1, prob = Vecnext, replace = T) 
    Vecnext[inext[1]]=Vecnext[inext[1]]-1
    inext[2] = sample(x = 1:n, size = 1, prob = Vecnext)
    Vecnext[inext[2]] = Vecnext[inext[2]]-1
    Vecnext[sum(inext)] = Vecnext[sum(inext)]+1
    
    count = count + 1
    Vecstates[count, ] = Vecnext 
    k = k - 1
  }
  # give a vector of mutation rate (corresponding to the SFS)
  
  mutrate = times*(Vecstates[-n,-n])
  mutrate = apply(mutrate, 2, sum)*theta/2
  Vecmut = rpois(n = n-1, lambda = mutrate)
  
  if(T_total == T){times = T_tot}
  return(list(times, Vecstates, Vecmut))
}
```

## Examples

These are a few examples of how to use this function,
example1 and example2 are exactly the same except for the output
of the time. While the first one gives the $\tau_k$, meaning the times spend with k_lineages, the second one gives the $T_{total_k}$ at each time step, i.e. the sum of all lineage branch length with k_lineages.

```{r}
# with T_MRCA
set.seed(42)
example1 = ncsim(n = 10, theta = 100)
print(example1)
```

```{r}
# with T_Total
set.seed(42)
example2 = ncsim(n = 10, theta = 100, T_total = T)
print(example2)
```

Considering many simulations, we can observe the mean SFS of the n-coalescent model. In particular this simulation confirmms that the number of singletons, doubletons, ... follows the formula presented in ,
$$
  \xi_i = \frac{\theta_i}{i}
$$

In that case if we take $n=10$, $\theta=100$ and the number of simulation is 10000, we obtain the following plot
```{r}

simulationSFS = replicate(10000, ncsim(n = 10, theta = 100)[3])
simulationSFS = matrix(unlist(simulationSFS), ncol = 10-1, byrow = T)

meanSFS = apply(simulationSFS,2,mean)
q1SFS = apply(simulationSFS,2,quantile,0.05)
q2SFS = apply(simulationSFS,2,quantile,0.95)
print(meanSFS)

plot(q2SFS, type = 'l', ylab = 'mean mutation number', xlab = 'lineage size', ylim = c(0,max(q2SFS)))
lines(1:9,meanSFS)
lines(q1SFS)
```

