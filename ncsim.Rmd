---
title: "ncsim"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The theory

```{r}
LambdaB = function(m,k,alpha=1){
  lmk=beta(k-alpha,m-k+alpha)/beta(alpha,2-alpha)
  return(lmk)
  }
```


## Aim:
   This function leads to a simulation of a gene tree considering the n-coalescent.

## Inputs:
   'n' the number of individuals,
   
   'theta' the population mutation rate,
   
   'T_total' a logical value to give the total branch length of the tree between each coalescent event (i.e. T_total will be the sum of the time given in output).

## Outputs:
   't' a vector with the time spent in each state,
   
   'Vecstates' a vector with the transient state for this simulation,
   
   'Vecmut' the simulated SFS.

```{r}
ncsim = function(n, theta = 10, model = 'n', T_total = FALSE){
  
  # Initialisation
  times = NULL; T_tot = NULL
  
  k = n  # number of distinct lineages
  count = 1  # because k will not goes just from 1 to size 
  Matstates = matrix(0, nrow=1, ncol=n)
  Matstates[1, ] = c(n, rep(0, n-1))
  Vecnext=Matstates[1,]
  Vecmut = rep(0, n-1)  # the number of mutation (in SFS)

  # This loop will continue until reaching the MRCA
  # (until just one lineage)
  while (k > 1){
 
    Vecrate = c(0,k*(k-1)/2,rep(0,n-2))
    for (i in 2:k){Vecrate[i]=(LambdaB(k, i, alpha = 0.1))*choose(k, i)}
    # plot(Vecrate)
    # Each coalescent time follow a exp dsitribution
    # with a parameter lambda given by the rate matrix

    lambda=sum(Vecrate)
    times[count] = rexp(n=1, rate=lambda)
    kmerger=sample(1:n, 1, prob = Vecrate/sum(Vecrate))
    
    
    if(T_total == TRUE){T_tot[count] = times[count]*k} 
           
    # Need this condition because the last coalescent leads to MRCA
    # and is not represented in the state matrix
    # Vector of probability to go to each other states

    inext = NULL
    # sample two times instead of one (with size 2)
    # to remove 2 of vecnext if the sample choose 
    # two times the same lineage size
    for (i in 1:kmerger){
      inext[i] = sample(x = 1:n, size = 1, prob = Vecnext, replace = T) 
      Vecnext[inext[i]]=Vecnext[inext[i]]-1
    }
    Vecnext[sum(inext)] = Vecnext[sum(inext)]+1
    
    count = count + 1
    Matstates = rbind(Matstates, Vecnext, deparse.level = 0)
    k = k - (kmerger-1)
  }
  # give a vector of mutation rate (corresponding to the SFS)
  
  mutrate = matrix(times*(Matstates[-count,-n])*(theta/2), ncol=n-1)
  mutrate = apply(mutrate, 2, sum)


  Vecmut = rpois(n = n-1, lambda = mutrate)
  
  if(T_total == T){times = T_tot}
  return(list(times, Matstates, Vecmut))
}
```

## Examples

These are a few examples of how to use this function,
example1 and example2 are exactly the same except for the output
of the time. While the first one gives the $\tau_k$, meaning the times spend with k_lineages, the second one gives the $T_{total_k}$ at each time step, i.e. the sum of all lineage branch length with k_lineages.

```{r}
# with T_MRCA
#set.seed(42)
example1 = ncsim(n = 10, theta = 100)
print(example1)
plot(example1[[1]])
plot(example1[[3]])
``` 

```{r}
# with T_Total
set.seed(42)
example2 = ncsim(n = 10, theta = 100, T_total = T)
print(example2)
plot(example2[[1]])
```

Considering many simulations, we can observe the mean SFS of the n-coalescent model. In particular this simulation confirmms that the number of singletons, doubletons, ... follows the formula presented in ,
$$
  \xi_i = \frac{\theta_i}{i}
$$

In that case if we take $n=10$, $\theta=100$ and the number of simulation is 10000, we obtain the following plot
```{r}
n=10
simulationSFS = replicate(1000, ncsim(n = n, theta = 1000)[3])
simulationSFS = matrix(unlist(simulationSFS), ncol = n-1, byrow = T)

meanSFS = apply(simulationSFS,2,mean)
q1SFS = apply(simulationSFS,2,quantile,0.05)
q2SFS = apply(simulationSFS,2,quantile,0.95)
print(meanSFS)

plot(q2SFS, type = 'l', ylab = 'mean mutation number', xlab = 'lineage size', ylim = c(0,max(q2SFS)))
lines(1:(n-1),meanSFS,col='red')
lines(q1SFS)
```