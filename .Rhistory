# with a parameter lambda given by the rate matrix
times[count] = rexp(n=1, rate = lambda)
if(T_total == TRUE){T_tot[count] = times[count]*k}
# Need this condition because the last coalescent leads to MRCA
# and is not represented in the state matrix
# Vector of probability to go to each other states
Vecnext = Vecstates[count,]
inext = NULL
# sample two times instead of one (with size 2)
# to remove 2 of vecnext if the sample choose
# two times the same lineage size
inext[1] = sample(x = 1:n, size = 1, prob = Vecnext)
Vecnext[inext[1]]=Vecnext[inext[1]]-1
inext[2] = sample(x = 1:n, size = 1, prob = Vecnext)
Vecnext[inext[2]] = Vecnext[inext[2]]-1
Vecnext[sum(inext)] = Vecnext[sum(inext)]+1
count = count + 1
Vecstates[count, ] = Vecnext
k = k - 1
}
# give a vector of mutation rate (corresponding to the SFS)
print(times)
mutrate = times*apply(Vecstates, 2, 'sum')*theta/2
Vecmut = Vecmut + rpois(n = n-1, lambda = mutrate)
if(T_total == T){T_tot = times}
return(list(times, Vecstates, Vecmut))
}
simulDyn(10,10,0,T)
simulDyn(10,10,0,T)
simulDyn = function(n, theta = 10, recombrate = 0, T_total = FALSE){
# Initialisation
times = NULL
k = n
count = 1 # because i will not goes just from 1 to size
Vecstates = matrix(0, nrow=n, ncol=n)
Vecstates[1, ] = c(n, rep(0, n-1))
Vecmut = rep(0, n-1) # the number of mutation (in SFS)
T_tot = NULL
# This loop will continue until reaching the MRCA
# because it should be as much coalescent event
# as the number of lineages - 1
while (k >= 2){
lambda = k*(k-1)/2
# Each coalescent time follow a exp dsitribution
# with a parameter lambda given by the rate matrix
times[count] = rexp(n=1, rate = lambda)
if(T_total == TRUE){T_tot[count] = times[count]*k}
# Need this condition because the last coalescent leads to MRCA
# and is not represented in the state matrix
# Vector of probability to go to each other states
Vecnext = Vecstates[count,]
inext = NULL
# sample two times instead of one (with size 2)
# to remove 2 of vecnext if the sample choose
# two times the same lineage size
inext[1] = sample(x = 1:n, size = 1, prob = Vecnext)
Vecnext[inext[1]]=Vecnext[inext[1]]-1
inext[2] = sample(x = 1:n, size = 1, prob = Vecnext)
Vecnext[inext[2]] = Vecnext[inext[2]]-1
Vecnext[sum(inext)] = Vecnext[sum(inext)]+1
count = count + 1
Vecstates[count, ] = Vecnext
k = k - 1
}
# give a vector of mutation rate (corresponding to the SFS)
print(times)
mutrate = times*apply(Vecstates[,-n], 2, 'sum')*theta/2
Vecmut = Vecmut + rpois(n = n-1, lambda = mutrate)
if(T_total == T){times = T_tot}
return(list(times, Vecstates, Vecmut))
}
simulDyn(10,10,0,T)
simulDyn(10,10,0,T)
simulDyn = function(n, theta = 10, recombrate = 0, T_total = FALSE){
# Initialisation
times = NULL; T_tot = NULL
k = n # number of distinct lineages
count = 1 # because k will not goes just from 1 to size
Vecstates = matrix(0, nrow=n, ncol=n)
Vecstates[1, ] = c(n, rep(0, n-1))
Vecmut = rep(0, n-1) # the number of mutation (in SFS)
# This loop will continue until reaching the MRCA
# (until just one lineage)
while (k > 1){
lambda = k*(k-1)/2
# Each coalescent time follow a exp dsitribution
# with a parameter lambda given by the rate matrix
times[count] = rexp(n=1, rate=lambda)
if(T_total == TRUE){T_tot[count] = times[count]*k}
# Need this condition because the last coalescent leads to MRCA
# and is not represented in the state matrix
# Vector of probability to go to each other states
Vecnext = Vecstates[count,]
inext = NULL
# sample two times instead of one (with size 2)
# to remove 2 of vecnext if the sample choose
# two times the same lineage size
inext[1] = sample(x = 1:n, size = 1, prob = Vecnext)
Vecnext[inext[1]]=Vecnext[inext[1]]-1
inext[2] = sample(x = 1:n, size = 1, prob = Vecnext)
Vecnext[inext[2]] = Vecnext[inext[2]]-1
Vecnext[sum(inext)] = Vecnext[sum(inext)]+1
count = count + 1
Vecstates[count, ] = Vecnext
k = k - 1
}
# give a vector of mutation rate (corresponding to the SFS)
mutrate = times*apply(Vecstates[,-n], 2, 'sum')*theta/2
Vecmut = Vecmut + rpois(n = n-1, lambda = mutrate)
if(T_total == T){times = T_tot}
return(list(times, Vecstates, Vecmut))
}
simulDyn(10,10,0,T)
n=
10
Vecnext = c(1,2,3,4,5,6,7,8,9,10)
sample(x = 1:n, size = 1, prob = Vecnext)
sample(x = 1:n, size = 5, prob = Vecnext)
sample(x = 1:n, size = 10, prob = Vecnext)
sample(x = 1:n, size = 1, prob = Vecnext, replace = T)
sample(x = 1:n, size = 10, prob = Vecnext, replace = T)
Vecnext[sample(x = 1:n, size = 1, prob = Vecnext, replace = T)]
Vecnext[sample(x = 1:n, size = 10, prob = Vecnext, replace = T)]
count(Vecnext)
Vecnext = [5,1]
Vecnext = c(5,1)
sample(x = 1:2, size = 1, prob = Vecnext, replace = T)
sample(x = 1:2, size = 2, prob = Vecnext, replace = T)
sample(x = 1:2, size = 2, prob = Vecnext, replace = T)
a =sample(x = 1:2, size = 2, prob = Vecnext, replace = T)
a
Vecnext[a]
Vecnext = c(5,1,5)
a =sample(x = 1:5, size = 2, prob = Vecnext, replace = T)
a =sample(x = 1:3, size = 5, prob = Vecnext, replace = T)
a
a =sample(x = 1:3, size = 5, prob = Vecnext, replace = T)
a
Vecnext = c(5,1,5)
a =sample(x = 1:3, size = 5, prob = Vecnext, replace = T)
a
table(a)
gamma(1)
gamma(2)
gamma(0.5)
gamma = 1.5
gamma(1.5)
gamma(2)/(gamma(2-alpha)-gamma(alpha))*(x^(1-alpha))*((1-x)^alpha)*dx
lambda = function(alpha, x, dx){
gamma(2)/(gamma(2-alpha)-gamma(alpha))*(x^(1-alpha))*((1-x)^alpha)*dx
}
lambda(1.3,0.2,0.001)
integrate(sin(x), 0.2,8)
integrate(sin(), 0.2,8)
integrate(sin(x), 0.2,8)
x=1
integrate(sin(x), 0.2,8)
help('integrate')
integrate(sin, 0.2,8)
integrate(cos, 0.2,8)
pouet = function(x){sin(x)^2}
integrate
integrate(pouet)
integrate(pouet,0,10)
k=2
pouet = function(x){sin(x)^2-k}
integrate(pouet,0,10)
k=3
pouet = function(x){sin(x)^2-k}
integrate(pouet,0,10)
pouet = function(x){
x^(k-2) * (1-x)^(m-k) * gamma(2)/(gamma(2-alpha)-gamma(alpha))*(x^(1-alpha))*((1-x)^alpha)
}
m=3
k=2
alpha=1.5
pouet(0.3)
integrate(pouet,0,1)
m=8
k=3
alpha=2
integrate(pouet,0,1)
m=8
k=3
alpha=1.999
integrate(pouet,0,1)
alpha=1.5
integrate(pouet,0,1)
matrate = mat(0,ncol=5)
matrate = matrix(0,ncol=5)
matrate
matrate = diag(rep(0,m))
matrate
m=5
matrate = diag(rep(0,m))
matrate
m=5
vecrate = diag(rep(0,m))
prob = NULL
for (k in 2:m){
prob = prob + integrate(pouet,0,1)
}
a = integrate(pouet,0,1)
a
a$value
prob = prob + integrate(pouet,0,1)$value
prob = NULL
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value
}
prob
prob = NULL
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
}
prob
m=5
vecrate = diag(rep(0,m))
prob = NULL
for (k in 2:m){
prob = integrate(pouet,0,1)$value[1]
print(prob)
}
prob = 0
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
}
print(integrate(pouet,0,1)$value[1])
vecrate = diag(rep(0,m))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
vecrate[n-m+1, k]
}
}
n=5
vecrate = diag(rep(0,m))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
vecrate[n-m+1, k]
}
}
pouet = function(x){
x^(k-2) * (1-x)^(m-k) * gamma(2)/(gamma(2-alpha)-gamma(alpha))*(x^(1-alpha))*((1-x)^alpha)
}
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
vecrate[n-m+1, k]
}
}
alpha=1.5
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
vecrate[n-m+1, k]
}
}
vecrate = diag(rep(0,m))
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
Vecrate[n-m+1, k]
}
}
Vecrate = diag(rep(0,m))
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
Vecrate[n-m+1, k]
}
}
Vecrate
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
print(k)
print(m)
Vecrate[n-m+1, k]
}
}
Vecrate
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
print(k)
print(m)
Vecrate[n-m+1, k]=pouet
}
}
Vecrate[2, 3]
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
print(k)
print(m)
Vecrate[(n-m+1), k] = pouet
}
}
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
print(k)
print(m)
Vecrate[(n-m+1), (n-m+k)] = pouet
}
}
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
print(n-m+1)
print(n-m+k)
Vecrate[(n-m+1), (n-m+k)] = pouet
}
}
Vecrate
for (m in n:2){
for (k in 2:m){
prob = prob + integrate(pouet,0,1)$value[1]
print(prob)
print(n-m+1)
print(n-m+k)
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
Vecrate
for (m in n:2){
for (k in 2:m){
prob = integrate(pouet,0,1)$value[1]
print(prob)
print(n-m+1)
print(n-m+k)
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
Vecrate
diag(Vecrate)=apply(Vecrate,1,sum)
Vecrate
Vecrate = diag(rep(0,m))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = integrate(pouet,0,1)$value[1]
print(prob)
print(n-m+1)
print(n-m+k)
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
Vecrate
n=5
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = integrate(pouet,0,1)$value[1]
print(prob)
print(n-m+1)
print(n-m+k)
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
Vecrate
Exrate = Vecrate[,n]
Vecrate = Vecrate[,-n]
library(PhaseTypeGenetics)
Vecrate
contphasetype(c(1,0,0,0),Vecrate)
Vecrate = Vecrate[-n,-n]
contphasetype(c(1,0,0,0),Vecrate)
a = contphasetype(c(1,0,0,0),Vecrate)
rphasetype(a,1000)
b = rphasetype(a,1000)
barplot(b)
b = rphasetype(a,1000000)
t=seq(0,1,0.001)
b = qphasetype(a,t)
plot(b)
gamma(2)
alpha = 2
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
fx = function(x){
x^(k-2) * (1-x)^(m-k) * (gamma(2)/(gamma(2-alpha)-gamma(alpha))*(x^(1-alpha))*((1-x)^alpha))
}
n=5
alpha = 1.999
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
print(Vecrate)
n=5
alpha = 1.999
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = choose(k,m)*integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
print(Vecrate)
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = choose(m,k)*integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
print(Vecrate)
Exrate = Vecrate[,n]
Vecrate = Vecrate[-n,-n]
a = contphasetype(c(1,0,0,0),Vecrate)
help('qphasetype')
a = contphasetype(c(1,0,0,0),Vecrate)
p=seq(0,1,0.001)
b=qphasetype(a,p)
plot(b)
a = contphasetype(c(1,0,0,0),Vecrate)
p=seq(0,4,0.01)
b=dphasetype(a,p)
plot(b)
p=seq(0,8,0.01)
b=dphasetype(a,p)
plot(b)
alpha = 1.5
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = choose(m,k)*integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
print(Vecrate)
Exrate = Vecrate[,n]
Vecrate = Vecrate[-n,-n]
a = contphasetype(c(1,0,0,0),Vecrate)
p=seq(0,8,0.01)
b=dphasetype(a,p)
plot(b)
n=5
alpha = 1
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = choose(m,k)*integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
n=5
alpha = 1.01
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = choose(m,k)*integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
print(Vecrate)
Exrate = Vecrate[,n]
Vecrate = Vecrate[-n,-n]
a = contphasetype(c(1,0,0,0),Vecrate)
p=seq(0,8,0.01)
b=dphasetype(a,p)
plot(b)
alpha = 1.2
Vecrate = diag(rep(0,n))
prob = 0
for (m in n:2){
for (k in 2:m){
prob = choose(m,k)*integrate(fx,0,1)$value[1]
Vecrate[(n-m+1), (n-m+k)] = prob
}
}
diag(Vecrate)=-apply(Vecrate,1,sum)
print(Vecrate)
Exrate = Vecrate[,n]
Vecrate = Vecrate[-n,-n]
a = contphasetype(c(1,0,0,0),Vecrate)
p=seq(0,8,0.01)
b=dphasetype(a,p)
plot(b)
