#' init_probs = c(0.9, 0.1, 0)
#' R = c(1,0,4)
#'
#' reward_discrete(init_probs = init_probs, subint_mat = subint_mat, reward = R)
#' ------------------------
#'
#'
#'
#' @export
reward_discrete <- function(phase_type = NULL, init_probs = NULL,
subint_mat = NULL, reward = NULL){
if (class(phase_type) == 'disc_phase_type'){  #  Check if the user provide a DPH object
init_probs <- phase_type$init_probs
subint_mat <- phase_type$subint_mat
}
# Check that the user provide information of the right format
# will not check that the object respect the DPH format
if (is.vector(init_probs) && is.matrix(subint_mat)) {
if (length(init_probs) == ncol(subint_mat)
&& ncol(subint_mat) == nrow(subint_mat)) {
# number of transient states
nb_states <- length(init_probs)
# Initialisation of the set of all T_tilde matrices
# i.e. all the rewarded submatrices to go from i to j
T_tilde_ij <- rep(list(as.list(1:nb_states)), nb_states)
# vector containing the size modified by the rewards,
# (i.e. reward = 0, size = 1 ; reward = i > 0, size = reward)
size <- reward + as.numeric(reward == 0)
# Building of each T_tilde_ij matrix
for (i in 1:nb_states) {
for (j in 1:nb_states) {
matij <- matrix(0, nrow = size[i], ncol = size[j])
matij[size[i], 1] <- subint_mat[i, j]
if(i == j) {
matij[-size[i], -1] <- diag(1, size[i] - 1)
}
T_tilde_ij[[i]][[j]] <- matij
}
}
# function necessary to have the right position in the order T_tilde
# will creates a vector which sum the previous elmts of the vector
# (e.g. 1 3 0 4 will be 1 4 4 8)
sumvec <- function(vec) {
for (i in 2:length(vec)){
vec[i] <- vec[i - 1] + vec[i]
}
return(vec)
}
abs_pos_p <- c(0, sumvec(size * (as.numeric(reward > 0)))) + 1
abs_pos_z <- c(0, sumvec(size * (as.numeric(reward == 0)))) + 1
# vector of state w/ positive-zero reward
p <- which(reward > 0)
z <- which(reward == 0)
T_tilde_states <- list(list(p, p), list(p, z),
list(z, p), list(z, z))
T_tilde <- list() # list containing T++, T+0, T0+ and T00
count <- 1 # To count the number of pass in the loop
for (i in T_tilde_states){
# Will give all the combinations of elements from
# T++, T+0, T0+ and T00 (respectively each loop iteration)
combn <- as.matrix(expand.grid(i[[1]],i[[2]]))
# Calculation of the measure of the submatrix
subT <- matrix(0, ncol = sum(size[i[[1]]]),
nrow = sum(size[i[[2]]]))
# Get the position of each elements
ifelse(i[[1]] == p, pos_row <- abs_pos_p, pos_row <- abs_pos_z)
ifelse(i[[2]] == p, pos_col <- abs_pos_p, pos_col <- abs_pos_z)
# for each combinations, add the corresponding matrix given by
# T_tilde_ij
for (j in 1:nrow(combn)){
selec_combn <- as.vector(combn[j,])
numcol <- (pos_row[selec_combn[1]]):
(pos_row[selec_combn[1] + 1] - 1)
numrow <- (pos_col[selec_combn[2]]):
(pos_col[selec_combn[2] + 1] - 1)
subT[numrow, numcol] <- T_tilde_ij[[selec_combn[2]]][[selec_combn[1]]]
}
T_tilde[[count]] <- subT
count <- count + 1
}
names(T_tilde) = c('pp', 'zp', 'pz', 'pp')
mat_T <- T_tilde$pp +
(T_tilde$pz
%*% solve(diag(1, ncol(T_tilde$zz)) - T_tilde$zz)
%*% T_tilde$zp)
init_probs_p <- NULL
for (i in 1:length(p)){
init_probs_p <- c(init_probs_p, init_probs[p[i]],
rep(0, reward[p[i]] - 1))
}
init_probs_z <- init_probs[z]
alpha <- init_probs_p +
(init_probs_z
%*% solve(diag(1,ncol(T_tilde$zz)) - T_tilde$zz)
%*% T_tilde$zp)
obj <- disc_phase_type(mat_T, alpha)
return(obj)
}else{
stop('Wrong dimensions')
}
}else{
stop('Wrong type of object')
}
}
subint_mat = matrix(c(0.4, 0, 0, 0.24, 0.4, 0, 0.12, 0.2, 0.5), ncol = 3)
init_probs = c(0.9, 0.1, 0)
reward = c(1,0,4)
reward_discrete(init_probs = init_probs,
subint_mat = subint_mat, reward = reward)
#' \code{disc_phase_type} class
#'
#' Description of the class \code{disc_phase_type}, which represents discrete
#' phase-type distributions.
#'
#' \code{reward_DPH} is the function to attribute a non-negative
#' reward vector to a discrete phase-type distribution.
#'
#' @param DPH a disc_phase_type object or \code{NULL} (default).
#' @param init_probs vector, a one-row matrix or \code{NULL} (default).
#' @param subint_mat matrix or \code{NULL} (default).
#' @param reward vector, a one-row matrix or \code{NULL} (default).
#'
#' @usage reward_DPH(DPH = NULL, init_probs = NULL, subint_mat = NULL,
#' reward = NULL)
#'
#' @examples
#'
#' subint_mat = matrix(c(0.4, 0, 0, 0.24, 0.4, 0, 0.12, 0.2, 0.5), ncol = 3)
#' init_probs = c(0.9, 0.1, 0)
#' R = c(1,0,4)
#'
#' reward_discrete(init_probs = init_probs, subint_mat = subint_mat, reward = R)
#' ------------------------
#'
#'
#'
#' @export
reward_discrete <- function(phase_type = NULL, init_probs = NULL,
subint_mat = NULL, reward = NULL){
if (class(phase_type) == 'disc_phase_type'){  #  Check if the user provide a DPH object
init_probs <- phase_type$init_probs
subint_mat <- phase_type$subint_mat
}
# Check that the user provide information of the right format
# will not check that the object respect the DPH format
if (is.vector(init_probs) && is.matrix(subint_mat)) {
if (length(init_probs) == ncol(subint_mat)
&& ncol(subint_mat) == nrow(subint_mat)) {
# number of transient states
nb_states <- length(init_probs)
# Initialisation of the set of all T_tilde matrices
# i.e. all the rewarded submatrices to go from i to j
T_tilde_ij <- rep(list(as.list(1:nb_states)), nb_states)
# vector containing the size modified by the rewards,
# (i.e. reward = 0, size = 1 ; reward = i > 0, size = reward)
size <- reward + as.numeric(reward == 0)
# Building of each T_tilde_ij matrix
for (i in 1:nb_states) {
for (j in 1:nb_states) {
matij <- matrix(0, nrow = size[i], ncol = size[j])
matij[size[i], 1] <- subint_mat[i, j]
if(i == j) {
matij[-size[i], -1] <- diag(1, size[i] - 1)
}
T_tilde_ij[[i]][[j]] <- matij
}
}
# function necessary to have the right position in the order T_tilde
# will creates a vector which sum the previous elmts of the vector
# (e.g. 1 3 0 4 will be 1 4 4 8)
sumvec <- function(vec) {
for (i in 2:length(vec)){
vec[i] <- vec[i - 1] + vec[i]
}
return(vec)
}
abs_pos_p <- c(0, sumvec(size * (as.numeric(reward > 0)))) + 1
abs_pos_z <- c(0, sumvec(size * (as.numeric(reward == 0)))) + 1
# vector of state w/ positive-zero reward
p <- which(reward > 0)
z <- which(reward == 0)
T_tilde_states <- list(list(p, p), list(p, z),
list(z, p), list(z, z))
T_tilde <- list() # list containing T++, T+0, T0+ and T00
count <- 1 # To count the number of pass in the loop
for (i in T_tilde_states){
# Will give all the combinations of elements from
# T++, T+0, T0+ and T00 (respectively each loop iteration)
combn <- as.matrix(expand.grid(i[[1]],i[[2]]))
# Calculation of the measure of the submatrix
subT <- matrix(0, ncol = sum(size[i[[1]]]),
nrow = sum(size[i[[2]]]))
# Get the position of each elements
ifelse(i[[1]] == p, pos_row <- abs_pos_p, pos_row <- abs_pos_z)
ifelse(i[[2]] == p, pos_col <- abs_pos_p, pos_col <- abs_pos_z)
# for each combinations, add the corresponding matrix given by
# T_tilde_ij
for (j in 1:nrow(combn)){
selec_combn <- as.vector(combn[j,])
numcol <- (pos_row[selec_combn[1]]):
(pos_row[selec_combn[1] + 1] - 1)
numrow <- (pos_col[selec_combn[2]]):
(pos_col[selec_combn[2] + 1] - 1)
subT[numrow, numcol] <- T_tilde_ij[[selec_combn[2]]][[selec_combn[1]]]
}
T_tilde[[count]] <- subT
count <- count + 1
}
names(T_tilde) = c('pp', 'zp', 'pz', 'zz')
mat_T <- T_tilde$pp +
(T_tilde$pz
%*% solve(diag(1, ncol(T_tilde$zz)) - T_tilde$zz)
%*% T_tilde$zp)
init_probs_p <- NULL
for (i in 1:length(p)){
init_probs_p <- c(init_probs_p, init_probs[p[i]],
rep(0, reward[p[i]] - 1))
}
init_probs_z <- init_probs[z]
alpha <- init_probs_p +
(init_probs_z
%*% solve(diag(1,ncol(T_tilde$zz)) - T_tilde$zz)
%*% T_tilde$zp)
obj <- disc_phase_type(mat_T, alpha)
return(obj)
}else{
stop('Wrong dimensions')
}
}else{
stop('Wrong type of object')
}
}
subint_mat = matrix(c(0.4, 0, 0, 0.24, 0.4, 0, 0.12, 0.2, 0.5), ncol = 3)
init_probs = c(0.9, 0.1, 0)
reward = c(1,0,4)
reward_discrete(init_probs = init_probs,
subint_mat = subint_mat, reward = reward)
a = list()
a = list(a)
a
a = list
names(a) = ('a','b','c')
names(a) = c('a','b','c')
a = list()
names(a) = c('a','b','c')
# list containing T++, T+0, T0+ and T00
T_tilde <- list('pp' = 0, 'zp' = 0,
'pz' = 0, 'zz' = 0)
T_tilde
#' \code{disc_phase_type} class
#'
#' Description of the class \code{disc_phase_type}, which represents discrete
#' phase-type distributions.
#'
#' \code{reward_DPH} is the function to attribute a non-negative
#' reward vector to a discrete phase-type distribution.
#'
#' @param DPH a disc_phase_type object or \code{NULL} (default).
#' @param init_probs vector, a one-row matrix or \code{NULL} (default).
#' @param subint_mat matrix or \code{NULL} (default).
#' @param reward vector, a one-row matrix or \code{NULL} (default).
#'
#' @usage reward_DPH(DPH = NULL, init_probs = NULL, subint_mat = NULL,
#' reward = NULL)
#'
#' @examples
#'
#' subint_mat = matrix(c(0.4, 0, 0, 0.24, 0.4, 0, 0.12, 0.2, 0.5), ncol = 3)
#' init_probs = c(0.9, 0.1, 0)
#' R = c(1,0,4)
#'
#' reward_discrete(init_probs = init_probs, subint_mat = subint_mat, reward = R)
#' ------------------------
#'
#'
#'
#' @export
reward_discrete <- function(phase_type = NULL, init_probs = NULL,
subint_mat = NULL, reward = NULL){
#  Check if the user provide a DPH object
if (class(phase_type) == 'disc_phase_type'){
init_probs <- phase_type$init_probs
subint_mat <- phase_type$subint_mat
}
# Check that the user provide information of the right format
# will not check that the object respect the DPH format
if (is.vector(init_probs) && is.matrix(subint_mat)) {
if (length(init_probs) == ncol(subint_mat)
&& ncol(subint_mat) == nrow(subint_mat)) {
# number of transient states
nb_states <- length(init_probs)
# Initialisation of the set of all T_tilde matrices
# i.e. all the rewarded submatrices to go from i to j
T_tilde_ij <- rep(list(as.list(1:nb_states)), nb_states)
# vector containing the size modified by the rewards,
# (i.e. reward = 0, size = 1 ; reward = i > 0, size = reward)
size <- reward + as.numeric(reward == 0)
# Building of each T_tilde_ij matrix
for (i in 1:nb_states) {
for (j in 1:nb_states) {
matij <- matrix(0, nrow = size[i], ncol = size[j])
matij[size[i], 1] <- subint_mat[i, j]
if(i == j) {
matij[-size[i], -1] <- diag(1, size[i] - 1)
}
T_tilde_ij[[i]][[j]] <- matij
}
}
# function necessary to have the right position in the order T_tilde
# will creates a vector which sum the previous elmts of the vector
# (e.g. 1 3 0 4 will be 1 4 4 8)
sumvec <- function(vec) {
for (i in 2:length(vec)){
vec[i] <- vec[i - 1] + vec[i]
}
return(vec)
}
abs_pos_p <- c(0, sumvec(size * (as.numeric(reward > 0)))) + 1
abs_pos_z <- c(0, sumvec(size * (as.numeric(reward == 0)))) + 1
# vector of state w/ positive-zero reward
p <- which(reward > 0)
z <- which(reward == 0)
T_tilde_states <- list(list(p, p), list(p, z),
list(z, p), list(z, z))
# list containing T++, T+0, T0+ and T00
T_tilde <- list('pp' = 0, 'zp' = 0,
'pz' = 0, 'zz' = 0)
count <- 1 # To count the number of pass in the loop
for (i in T_tilde_states){
# Will give all the combinations of elements from
# T++, T+0, T0+ and T00 (respectively each loop iteration)
combn <- as.matrix(expand.grid(i[[1]],i[[2]]))
# initialisation of the submatrix
T_tilde[[count]] <- matrix(0, ncol = sum(size[i[[1]]]),
nrow = sum(size[i[[2]]]))
# Get the position of each elements
ifelse(i[[1]] == p, pos_row <- abs_pos_p, pos_row <- abs_pos_z)
ifelse(i[[2]] == p, pos_col <- abs_pos_p, pos_col <- abs_pos_z)
# for each combinations, add the corresponding matrix given by
# T_tilde_ij
for (j in 1:nrow(combn)){
selec_combn <- as.vector(combn[j,])
numcol <- (pos_row[selec_combn[1]]):
(pos_row[selec_combn[1] + 1] - 1)
numrow <- (pos_col[selec_combn[2]]):
(pos_col[selec_combn[2] + 1] - 1)
T_tilde[[count]][numrow, numcol] <- T_tilde_ij[[selec_combn[2]]][[selec_combn[1]]]
}
count <- count + 1
}
mat_T <- T_tilde$pp +
(T_tilde$pz
%*% solve(diag(1, ncol(T_tilde$zz)) - T_tilde$zz)
%*% T_tilde$zp)
init_probs_p <- NULL
for (i in 1:length(p)){
init_probs_p <- c(init_probs_p, init_probs[p[i]],
rep(0, reward[p[i]] - 1))
}
init_probs_z <- init_probs[z]
alpha <- init_probs_p +
(init_probs_z
%*% solve(diag(1,ncol(T_tilde$zz)) - T_tilde$zz)
%*% T_tilde$zp)
obj <- disc_phase_type(mat_T, alpha)
return(obj)
}else{
stop('Wrong dimensions')
}
}else{
stop('Wrong type of object')
}
}
subint_mat = matrix(c(0.4, 0, 0, 0.24, 0.4, 0, 0.12, 0.2, 0.5), ncol = 3)
init_probs = c(0.9, 0.1, 0)
reward = c(1,0,4)
reward_discrete(init_probs = init_probs,
subint_mat = subint_mat, reward = reward)
a=c(1,2,3,4)
i=c(2,3,4)
a[i] = a[i-1]+a[i]
a
a[i] = a[i-(0:2)]+a[i]
a
a=c(1,2,3,4)
a[i] = a[i-(0:2)]+a[i]
a
a[i] = sum(a[i])
a
a[i]
i
sum(a[i:length(a)])
a[i]
a=c(1,2,3,4)
a
a[list(i)]
list(a[i])
a
a[i]+a[-i]
a
a[i]+a[-i[i]]
sum(a)-a[i:rep(length(a),length(a))]
a[c(1,2,3):c(3,2,1)]
sum(a[<=i])
a[i]
a[i<i]
a = sum(a[i])
a
a=c(1,2,3,4)
b = c(a[1], a[1:2], a[1:3], a[1:4])
b
b = c(a[1], sum(a[1:2]), sum(a[1:3]), sum(a[1:4]))
b
lapply(a, sum(a[1:i]))
inv(a)
a[-]
rev(a)
rev(a)
knitr::opts_chunk$set(echo = TRUE)
summaries4 = function(nSFS, bSFS, nSD, bSD){
n=ncol(nSFS)-1
xn = nSFS[,1]/(apply(nSFS,1,sum)+0.00001)
xb = bSFS[,1]/(apply(bSFS,1,sum)+0.00001)
yn = apply(nSFS[,round(n-n/10):n],1,sum)/(apply(nSFS,1,sum)+0.00001)
yb = apply(bSFS[,round(n-n/10):n],1,sum)/(apply(bSFS,1,sum)+0.00001)
zn = nSD[,1]/(apply(nSD,1,sum)+0.00001)
zb = bSD[,1]/(apply(bSD,1,sum)+0.00001)
return(c(xn,xb,zn,zb))
}
source('simcoal.R')
require(class)
require(MASS)
require(ggplot2)
nvbclass = function(alpha, FUN = summaries1, n=100, replicate=1000){
# initialisation of the matrix to stock he data
nSFS = matrix(0,ncol=n-1, nrow=replicate)
bSFS = matrix(0,ncol=n-1, nrow=replicate)
nSD = matrix(0,ncol=n, nrow=replicate)
bSD = matrix(0,ncol=n, nrow=replicate)
# Simulation of the number of the SFS and singletond distribution for n
for (i in 1:replicate){
simul = ncsim(n = n)
nSFS[i,] = mutsim(simul)
nSD[i,] = singletondistr(simul)
}
# Same for Beta
for (i in 1:replicate){
simul = bcsim(n = n, alpha = alpha)
bSFS[i,] = mutsim(simul)
bSD[i,] = singletondistr(simul)
}
# calculation of the summaries
## [ THIS PART CHANGES FROM ONE nbvclass FUNCTION TO THE OTHER ] ##
results = FUN(nSFS, bSFS, nSD, bSD)
return(results)
}
classification = function(alpha, n, FUN, replicate = 1000){
train = nvbclass(alpha = alpha, FUN = FUN, n=n, replicate = replicate)
test = nvbclass(alpha = alpha, FUN = FUN, n=n, replicate = replicate)
train = matrix(train, ncol=2)
test = matrix(test, ncol=2)
class = factor(c(rep('n',replicate),rep('b',replicate)))
a = knn(train = train, test = test, cl = class, k = 1)
predknn = (length(which(a[1:replicate]=='n'))+length(which(a[replicate:(2*replicate)]=='b')))*100/(2*replicate)
plknn = cbind(data.frame(test), a)
q = qda(train, class)
z = predict(q, test)
plqda = cbind(data.frame(test), z$class)
predqda = (length(which(z$class[1:replicate]=='n'))+length(which(z$class[replicate:(2*replicate)]=='b')))*100/(2*replicate)
q = lda(train, class)
z = predict(q, test)
pllda = cbind(data.frame(test), z$class)
predlda = (length(which(z$class[1:replicate]=='n'))+length(which(z$class[replicate:(2*replicate)]=='b')))*100/(2*replicate)
return(list(predknn,predqda,predlda,plknn,plqda,pllda))
}
summaries4 = function(nSFS, bSFS, nSD, bSD){
n=ncol(nSFS)-1
xn = nSFS[,1]/(apply(nSFS,1,sum)+0.00001)
xb = bSFS[,1]/(apply(bSFS,1,sum)+0.00001)
yn = apply(nSFS[,round(n-n/10):n],1,sum)/(apply(nSFS,1,sum)+0.00001)
yb = apply(bSFS[,round(n-n/10):n],1,sum)/(apply(bSFS,1,sum)+0.00001)
zn = nSD[,1]/(apply(nSD,1,sum)+0.00001)
zb = bSD[,1]/(apply(bSD,1,sum)+0.00001)
return(c(xn,xb,zn,zb))
}
step = 5
vecalpha = seq(1,1.9,length.out = step)
vecn = seq(10,100,length.out = step)
results = data.frame(accuracy = rep(0, times = step*step),
cl = rep('qda',step*step),
alpha = rep(vecalpha,step),
n = rep(vecn,each = step))
for (n in 1:step){
for (i in 1:step){
giveclass=classification(alpha = vecalpha[i], FUN = summaries4,
n = round(vecn[n]), replicate = 1000)
#print(ggplot(data=giveclass[[2]], aes(x = X1, y = X3)) + geom_point(aes(colour=giveclass[[2]][,4])))
results$accuracy[i+(n-1)*step] = giveclass[[1]]
print(n*step+i-step)
}
}
for (n in 1:step){
for (i in 1:step){
giveclass=classification(alpha = vecalpha[i], FUN = summaries4,
n = round(vecn[n]), replicate = 1000)
#print(ggplot(data=giveclass[[2]], aes(x = X1, y = X3)) + geom_point(aes(colour=giveclass[[2]][,4])))
results$accuracy[i+(n-1)*step] = giveclass[[1]]
print(n*step+i-step)
}
}
ggplot(data = results,aes(x = alpha, y = accuracy)) +
geom_line(aes(col = as.character(n)))
